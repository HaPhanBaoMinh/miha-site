[{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks ![[Pasted image 20250809151025.png | 500]]]] That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls. Now imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces ![[Pasted image 20250809143512.png|500]]\nTL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks { width=500px } That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. ![[Pasted image 20250809110428.png|500]]\n3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /. 4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” ![[Pasted image 20250809160952.png|500]] TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood??"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood?"},{"content":"1. Why should you care? You type:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood?"},{"content":"1. Why should you care? docker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood?"},{"content":"1. Why should you care? When you run a Docker container, like this:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood?"},{"content":"1. Why should you care? When you run a Docker container, like this:\ndocker run nginx \u0026hellip;and somehow, a tiny isolated world pops into existence — with its own filesystem, processes, hostname, and even IP address.\nBut ever wondered why it works? Let’s peek under the hood — cgroups, namespaces, image layers, and all the nerdy stuff you pretend to understand.\n2. The magic ingredient When Docker “creates” a container, it’s really:\nStarting a process on the host. Wrapping that process in namespaces (to hide other stuff). Putting it inside cgroups (to limit resources). Giving it a filesystem view (via mount namespaces \u0026amp; overlay filesystems). Let’s see this in action.\n3. Namespaces — _What can you see? Think of your computer as a giant open space. Without rules, every program can see:\nAll files All processes All networks That’s like living in a house with no walls.\nNow imagine building invisible walls around each app. Each app now thinks it\u0026rsquo;s the only one living in the house. That invisible walls is namespaces TL;DR Namespaces Namespaces = isolation of what you can see. MNT namespaces make each container think it owns /. Other namespaces isolate PID, NET, IPC, UTS, USER, and TIME. 3.1 Spin up a container docker run --name nginx -d nginx 3.2 Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 240649 Why?\nThis PID is the main process running inside the container, but from the host’s point of view.\n3.3 Check what namespaces a container is using sudo ls -l /proc/240649/ns OUTPUT: total 0 lrwxrwxrwx 1 root root 0 Aug 8 13:50 cgroup -\u0026gt; \u0026#39;cgroup:[4026531835]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 ipc -\u0026gt; \u0026#39;ipc:[4026532606]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:47 net -\u0026gt; \u0026#39;net:[4026532608]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 pid_for_children -\u0026gt; \u0026#39;pid:[4026532607]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 time_for_children -\u0026gt; \u0026#39;time:[4026531834]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 user -\u0026gt; \u0026#39;user:[4026531837]\u0026#39; lrwxrwxrwx 1 root root 0 Aug 8 13:50 uts -\u0026gt; \u0026#39;uts:[4026532264]\u0026#39; Cool, you can see all the namespaces this container process is attached to. Each entry follows the pattern:\n\u0026lt;namespace_type\u0026gt; -\u0026gt; \u0026#39;\u0026lt;namespace_type\u0026gt;:[namespace_ID]\u0026#39; - namespace_type → which namespace we’re looking at (mnt, net, pid, etc.) - namespace_ID → the unique ID of that namespace in the kernel. - If two processes have the same ID for a given type, they share that namespace.\nTypes include:\nmnt — Filesystem view pid — Process IDs net — Network interfaces ipc — Inter-process communication uts — Hostname/domain user — User/group IDs time — System clocks Tip: If two processes share the same namespace ID for a type, they share that namespace\n3.4 Peek at the MNT (mount) namespace mnt -\u0026gt; \u0026#39;mnt:[4026532263]\u0026#39; You can exec into the container and see that the container has its own filesystem\ndocker exec -it nginx ls / OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Looks like a complete Linux filesystem… but it’s just a mapped folder on the host. 3.5 Where is it really stored? # Get container\u0026#39;s ID docker inspect --format \u0026#39;{{.Id}}\u0026#39; nginx OUTPUT: 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb # Find the container’s root filesystem on the host docker inspect --format \u0026#39;{{.GraphDriver.Data.MergedDir}}\u0026#39; 967db174494915398f42a23819eda2a1e4fb72fb2879ae70a87d348c5d1eebfb OUTPUT: /var/lib/docker/overlay2/a56aaad745c20bba.../merged # List all filesystem sudo ls /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: \u0026lt;empty\u0026gt; If you ls that folder from your normal shell, it might look empty.\nWhy that?\nYou’re in the wrong mount namespace.\n3.6 Sneak into Docker’s mount namespace Docker keeps these mounts in dockerd’s private mount namespace. To see them, you need to sneak in:\n# Enter dockerd\u0026#39;s mount namespace sudo nsenter --target $(pgrep -x dockerd | head -n1) --mount -- bash # Now list the container\u0026#39;s root filesystem ls -la /var/lib/docker/overlay2/a56aaad745c20bba.../merged OUTPUT: bin boot dev docker etc home lib lib64 media mnt opt proc root run sbin ... Boom — now you see what the container sees as /.\n4. Cgroups — How much can you use? Namespaces hide stuff.\nCgroups control how much you get to use.\nThey’re like a bouncer at a party:\n“You, only 50% CPU.” “You, max 256 MB RAM.” “You… no network for you.” TL;DR Cgroups Cgroups = limit how much resources a container can consume. Docker writes these limits to the cgroup filesystem. The kernel enforces them automatically. 4.1 Create a limited container docker run -m 256m --cpus=0.5 nginx This says:\nMax memory: 256 MB Max CPU: 0.5 cores 4.2 Find the cgroup path # Find its main process PID docker inspect --format \u0026#39;{{.State.Pid}}\u0026#39; nginx OUTPUT: 1984 # List cgroup memberships for that PID cat /proc/1984/cgroup OUTPUT: 0::/system.slice/docker-563720d58a5bdc46e6ce27d340cbf2cfe301ecaba2b67951da3770b6ac76cc4a.scope 0 → cgroup v2 unified hierarchy. system.slice → managed by systemd. **docker.docker_id.scope → group for this container’s processes. 4.3 See the actual limits cd /sys/fs/cgroup/system.slice/docker-\u0026lt;container_id\u0026gt;.scope OUTPUT: cpu.max memory.max memory.min cpu.idle ... cat cpu.max OUTOUT: 50000 100000 # 50000 100000 → 50ms of CPU time every 100ms = 0.5 cores cat memory.max OUTPUT: 268435456 # 268435456 bytes = 256 MB 5. Wrapping It All Up We just pulled back the curtain on what actually happens when you run a Docker container:\nNamespaces → Decide what you can see.\nYour container gets its own view of processes, filesystems, networks, etc. Like invisible walls separating roommates in the same house. Cgroups → Decide how much you can use.\nControl CPU, memory, PIDs, and more. Like a bouncer making sure no one eats all the snacks. Overlay Filesystem \u0026amp; Mount Namespaces → Give the container its own “root” directory.\nLooks like a complete OS, but it’s just a mapped folder on the host. Key Takeaways Docker containers are just processes with special kernel features applied. You can inspect namespaces via /proc/\u0026lt;PID\u0026gt;/ns to see isolation in action. You can inspect cgroups via /sys/fs/cgroup to see and adjust resource limits. The “magic” is inside the Linux kernel, not in Docker itself. Final thought:\nNext time someone says “containers are lightweight VMs,” you can smile knowingly — because you actually understand the Linux magic making it happen.\n","permalink":"http://localhost:1313/miha-site/blog/docker_container_001/","summary":"Ever wondered what happens when you run a Docker container? Let\u0026rsquo;s dive into the Linux magic behind namespaces, cgroups, and overlay filesystems that make it all possible.","title":"Docker Containers: What the heck is really going on under the hood?"}]